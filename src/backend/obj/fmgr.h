/*-------------------------------------------------------------------------
 *
 * fmgr.h--
 *    Definitions for using internal procedures.
 *
 *
 * Copyright (c) 1994, Regents of the University of California
 *
 * : Gen_fmgrtab.sh,v 1.3 1996/07/22 21:55:40 scrappy Exp $
 *
 * NOTES
 *	******************************
 *	*** DO NOT EDIT THIS FILE! ***
 *	******************************
 *
 *	It has been GENERATED by /home/jim/source_code/my_postgre95/src/backend/utils/Gen_fmgrtab.sh
 *	from /home/jim/source_code/my_postgre95/src/backend/catalog/pg_proc.h
 *
 *-------------------------------------------------------------------------
 */
#ifndef	FMGR_H
#define FMGR_H

#include "postgres.h"			/* for some prototype typedefs */

/*
 *	Maximum number of arguments for a built-in function.
 *
 *	XXX note that you cannot call a function with more than 8
 *	    arguments from the user level since the catalogs only
 *	    store 8 argument type values for type-checking ...
 */
#define	MAXFMGRARGS	9

typedef struct {
    char *data[MAXFMGRARGS];
} FmgrValues;

/*
 * defined in fmgr.c
 */
extern char *fmgr_c(func_ptr user_fn, Oid func_id, int n_arguments,
	FmgrValues *values, bool *isNull);
extern void fmgr_info(Oid procedureId, func_ptr *function, int *nargs);
extern char *fmgr(Oid procedureId, ... );
extern char *fmgr_ptr(func_ptr user_fn, Oid func_id, ... );
extern char *fmgr_array_args(Oid procedureId, int nargs,
			     char *args[], bool *isNull);

/*
 * defined in dfmgr.c
 */
extern func_ptr fmgr_dynamic(Oid procedureId, int *pronargs);
extern void load_file(char *filename);


/*
 *	For performance reasons, we often want to simply jump through a
 *	a function pointer (if it's valid, that is).  These calls have
 *	been macroized so we can run them through a routine that does
 *	sanity-checking (and so we can track them down more easily when
 *	we must).
 */
#ifdef TRACE_FMGR_PTR
#define	FMGR_PTR2(FP, FID, ARG1, ARG2) 	fmgr_ptr(FP, FID, 2, ARG1, ARG2)
#else
#define	FMGR_PTR2(FP, FID, ARG1, ARG2) 	((FP) ? (*((func_ptr)(FP)))(ARG1, ARG2) : fmgr(FID, ARG1, ARG2))
#endif

/*
 *	Flags for the builtin oprrest selectivity routines.
 */
#define	SEL_CONSTANT 	1	/* constant does not vary (not a parameter) */
#define	SEL_RIGHT	2 	/* constant appears to right of operator */

#define F_BOOLIN 28
#define F_BOOLOUT 29

#endif	/* FMGR_H */
